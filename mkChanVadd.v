//
// Generated by Bluespec Compiler, version 2014.07.A (build 34078, 2014-07-30)
//
// On Fri Feb 17 16:43:15 CST 2017
//
//
// Ports:
// Name                         I/O  size props
// RDY_start                      O     1
// result                         O    64 reg
// RDY_result                     O     1
// mc_client_req_rsp_request_get  O   153
// RDY_mc_client_req_rsp_request_get  O     1 reg
// RDY_mc_client_req_rsp_response_put  O     1
// mc_client_flush_request_get    O     1 const
// RDY_mc_client_flush_request_get  O     1 const
// RDY_mc_client_flush_response_put  O     1 const
// CLK                            I     1 clock
// RST_N                          I     1 reset
// start_aeid                     I     2 reg
// start_chan                     I     3 reg
// start_evenNotOdd               I     1 reg
// start_rd_base_1                I    48
// start_rd_limit_1               I    48 reg
// start_rd_base_2                I    48
// start_rd_limit_2               I    48 reg
// start_wr_base                  I    48
// start_wr_limit                 I    48 reg
// mc_client_req_rsp_response_put  I   102
// mc_client_flush_response_put   I     1 unused
// EN_start                       I     1
// EN_mc_client_req_rsp_response_put  I     1
// EN_mc_client_flush_response_put  I     1 unused
// EN_result                      I     1
// EN_mc_client_req_rsp_request_get  I     1
// EN_mc_client_flush_request_get  I     1 unused
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkChanVadd(CLK,
		  RST_N,

		  start_aeid,
		  start_chan,
		  start_evenNotOdd,
		  start_rd_base_1,
		  start_rd_limit_1,
		  start_rd_base_2,
		  start_rd_limit_2,
		  start_wr_base,
		  start_wr_limit,
		  EN_start,
		  RDY_start,

		  EN_result,
		  result,
		  RDY_result,

		  EN_mc_client_req_rsp_request_get,
		  mc_client_req_rsp_request_get,
		  RDY_mc_client_req_rsp_request_get,

		  mc_client_req_rsp_response_put,
		  EN_mc_client_req_rsp_response_put,
		  RDY_mc_client_req_rsp_response_put,

		  EN_mc_client_flush_request_get,
		  mc_client_flush_request_get,
		  RDY_mc_client_flush_request_get,

		  mc_client_flush_response_put,
		  EN_mc_client_flush_response_put,
		  RDY_mc_client_flush_response_put);
  input  CLK;
  input  RST_N;

  // action method start
  input  [1 : 0] start_aeid;
  input  [2 : 0] start_chan;
  input  start_evenNotOdd;
  input  [47 : 0] start_rd_base_1;
  input  [47 : 0] start_rd_limit_1;
  input  [47 : 0] start_rd_base_2;
  input  [47 : 0] start_rd_limit_2;
  input  [47 : 0] start_wr_base;
  input  [47 : 0] start_wr_limit;
  input  EN_start;
  output RDY_start;

  // actionvalue method result
  input  EN_result;
  output [63 : 0] result;
  output RDY_result;

  // actionvalue method mc_client_req_rsp_request_get
  input  EN_mc_client_req_rsp_request_get;
  output [152 : 0] mc_client_req_rsp_request_get;
  output RDY_mc_client_req_rsp_request_get;

  // action method mc_client_req_rsp_response_put
  input  [101 : 0] mc_client_req_rsp_response_put;
  input  EN_mc_client_req_rsp_response_put;
  output RDY_mc_client_req_rsp_response_put;

  // actionvalue method mc_client_flush_request_get
  input  EN_mc_client_flush_request_get;
  output mc_client_flush_request_get;
  output RDY_mc_client_flush_request_get;

  // action method mc_client_flush_response_put
  input  mc_client_flush_response_put;
  input  EN_mc_client_flush_response_put;
  output RDY_mc_client_flush_response_put;

  // signals for module outputs
  wire [152 : 0] mc_client_req_rsp_request_get;
  wire [63 : 0] result;
  wire RDY_mc_client_flush_request_get,
       RDY_mc_client_flush_response_put,
       RDY_mc_client_req_rsp_request_get,
       RDY_mc_client_req_rsp_response_put,
       RDY_result,
       RDY_start,
       mc_client_flush_request_get;

  // register fifo_sums_rCache
  reg [76 : 0] fifo_sums_rCache;
  wire [76 : 0] fifo_sums_rCache$D_IN;
  wire fifo_sums_rCache$EN;

  // register fifo_sums_rRdPtr
  reg [11 : 0] fifo_sums_rRdPtr;
  wire [11 : 0] fifo_sums_rRdPtr$D_IN;
  wire fifo_sums_rRdPtr$EN;

  // register fifo_sums_rWrPtr
  reg [11 : 0] fifo_sums_rWrPtr;
  wire [11 : 0] fifo_sums_rWrPtr$D_IN;
  wire fifo_sums_rWrPtr$EN;

  // register rg_aeid
  reg [1 : 0] rg_aeid;
  wire [1 : 0] rg_aeid$D_IN;
  wire rg_aeid$EN;

  // register rg_chan
  reg [2 : 0] rg_chan;
  wire [2 : 0] rg_chan$D_IN;
  wire rg_chan$EN;

  // register rg_evenNotOdd
  reg rg_evenNotOdd;
  wire rg_evenNotOdd$D_IN, rg_evenNotOdd$EN;

  // register rg_partial_sum
  reg [63 : 0] rg_partial_sum;
  wire [63 : 0] rg_partial_sum$D_IN;
  wire rg_partial_sum$EN;

  // register rg_rd_active_2
  reg rg_rd_active_2;
  wire rg_rd_active_2$D_IN, rg_rd_active_2$EN;

  // register rg_rd_base_1
  reg [47 : 0] rg_rd_base_1;
  wire [47 : 0] rg_rd_base_1$D_IN;
  wire rg_rd_base_1$EN;

  // register rg_rd_base_2
  reg [47 : 0] rg_rd_base_2;
  wire [47 : 0] rg_rd_base_2$D_IN;
  wire rg_rd_base_2$EN;

  // register rg_rd_limit_1
  reg [47 : 0] rg_rd_limit_1;
  wire [47 : 0] rg_rd_limit_1$D_IN;
  wire rg_rd_limit_1$EN;

  // register rg_rd_limit_2
  reg [47 : 0] rg_rd_limit_2;
  wire [47 : 0] rg_rd_limit_2$D_IN;
  wire rg_rd_limit_2$EN;

  // register rg_rd_pc
  reg [15 : 0] rg_rd_pc;
  wire [15 : 0] rg_rd_pc$D_IN;
  wire rg_rd_pc$EN;

  // register rg_reading
  reg rg_reading;
  wire rg_reading$D_IN, rg_reading$EN;

  // register rg_run_state
  reg [1 : 0] rg_run_state;
  reg [1 : 0] rg_run_state$D_IN;
  wire rg_run_state$EN;

  // register rg_vin1_turn
  reg rg_vin1_turn;
  wire rg_vin1_turn$D_IN, rg_vin1_turn$EN;

  // register rg_wr_active
  reg rg_wr_active;
  wire rg_wr_active$D_IN, rg_wr_active$EN;

  // register rg_wr_base
  reg [47 : 0] rg_wr_base;
  wire [47 : 0] rg_wr_base$D_IN;
  wire rg_wr_base$EN;

  // register rg_wr_limit
  reg [47 : 0] rg_wr_limit;
  wire [47 : 0] rg_wr_limit$D_IN;
  wire rg_wr_limit$EN;

  // register rg_wr_pc
  reg [15 : 0] rg_wr_pc;
  reg [15 : 0] rg_wr_pc$D_IN;
  wire rg_wr_pc$EN;

  // register rg_wr_rsp_drain_count
  reg [15 : 0] rg_wr_rsp_drain_count;
  reg [15 : 0] rg_wr_rsp_drain_count$D_IN;
  wire rg_wr_rsp_drain_count$EN;

  // register rg_x1
  reg [63 : 0] rg_x1;
  wire [63 : 0] rg_x1$D_IN;
  wire rg_x1$EN;

  // register rg_x1_valid
  reg rg_x1_valid;
  wire rg_x1_valid$D_IN, rg_x1_valid$EN;

  // ports of submodule fifo_reqs
  reg [152 : 0] fifo_reqs$D_IN;
  wire [152 : 0] fifo_reqs$D_OUT;
  wire fifo_reqs$CLR,
       fifo_reqs$DEQ,
       fifo_reqs$EMPTY_N,
       fifo_reqs$ENQ,
       fifo_reqs$FULL_N;

  // ports of submodule fifo_rsps
  wire [101 : 0] fifo_rsps$D_IN, fifo_rsps$D_OUT;
  wire fifo_rsps$CLR,
       fifo_rsps$DEQ,
       fifo_rsps$EMPTY_N,
       fifo_rsps$ENQ,
       fifo_rsps$FULL_N;

  // ports of submodule fifo_sums_memory
  wire [63 : 0] fifo_sums_memory$DIA,
		fifo_sums_memory$DIB,
		fifo_sums_memory$DOB;
  wire [10 : 0] fifo_sums_memory$ADDRA, fifo_sums_memory$ADDRB;
  wire fifo_sums_memory$ENA,
       fifo_sums_memory$ENB,
       fifo_sums_memory$WEA,
       fifo_sums_memory$WEB;

  // rule scheduling signals
  wire CAN_FIRE_RL_rg_wr_gen,
       WILL_FIRE_RL_rg_wr_gen,
       WILL_FIRE_RL_rg_wr_rsp_drain,
       WILL_FIRE_RL_rl_get_x1,
       WILL_FIRE_RL_rl_get_x2_sum_and_gen_wr_reqs,
       WILL_FIRE_RL_rl_rd_gen_0,
       WILL_FIRE_RL_rl_rd_gen_1;

  // inputs to muxes for submodule ports
  wire [152 : 0] MUX_fifo_reqs$enq_1__VAL_1,
		 MUX_fifo_reqs$enq_1__VAL_2,
		 MUX_fifo_reqs$enq_1__VAL_3;
  wire [63 : 0] MUX_rg_partial_sum$write_1__VAL_2;
  wire [47 : 0] MUX_rg_rd_base_1$write_1__VAL_2;
  wire [15 : 0] MUX_rg_rd_pc$write_1__VAL_1,
		MUX_rg_wr_pc$write_1__VAL_2,
		MUX_rg_wr_rsp_drain_count$write_1__VAL_2,
		MUX_rg_wr_rsp_drain_count$write_1__VAL_3;
  wire MUX_rg_rd_active_2$write_1__VAL_2,
       MUX_rg_reading$write_1__SEL_1,
       MUX_rg_wr_active$write_1__VAL_2;

  // remaining internal signals
  reg [6 : 0] CASE_fifo_reqsD_OUT_BITS_152_TO_146_16_fifo_r_ETC__q1;
  reg [2 : 0] CASE_mc_client_req_rsp_response_put_BITS_101_T_ETC__q2;
  wire [63 : 0] x3__h1893, x3__h3375, x3__h3482, x_wget__h1649;
  wire [47 : 0] next_base__h2815, next_base__h3590;
  wire [40 : 0] rg_rd_base_1_6_BITS_47_TO_9_7_CONCAT_rg_rd_bas_ETC___d50,
		rg_rd_base_2_3_BITS_47_TO_9_1_CONCAT_rg_rd_bas_ETC___d64,
		rg_wr_base_6_BITS_47_TO_9_11_CONCAT_rg_wr_base_ETC___d114,
		x__h2565,
		x__h2839,
		x__h3613;
  wire [11 : 0] x__h1976, x__h2078;
  wire rg_rd_base_2_3_BITS_47_TO_9_1_CONCAT_rg_rd_bas_ETC___d72,
       rg_wr_base_6_BITS_47_TO_9_11_CONCAT_rg_wr_base_ETC___d121;

  // action method start
  assign RDY_start = rg_run_state == 2'd0 ;

  // actionvalue method result
  assign result = rg_partial_sum ;
  assign RDY_result =
	     rg_run_state == 2'd2 && !rg_wr_active &&
	     rg_wr_rsp_drain_count == 16'd0 ;

  // actionvalue method mc_client_req_rsp_request_get
  assign mc_client_req_rsp_request_get =
	     { CASE_fifo_reqsD_OUT_BITS_152_TO_146_16_fifo_r_ETC__q1,
	       fifo_reqs$D_OUT[145:0] } ;
  assign RDY_mc_client_req_rsp_request_get = fifo_reqs$EMPTY_N ;

  // action method mc_client_req_rsp_response_put
  assign RDY_mc_client_req_rsp_response_put =
	     rg_run_state == 2'd2 && fifo_rsps$FULL_N ;

  // actionvalue method mc_client_flush_request_get
  assign mc_client_flush_request_get = 1'h0 ;
  assign RDY_mc_client_flush_request_get = 1'd0 ;

  // action method mc_client_flush_response_put
  assign RDY_mc_client_flush_response_put = 1'd0 ;

  // submodule fifo_reqs
  FIFO2 #(.width(32'd153), .guarded(32'd1)) fifo_reqs(.RST(RST_N),
						      .CLK(CLK),
						      .D_IN(fifo_reqs$D_IN),
						      .ENQ(fifo_reqs$ENQ),
						      .DEQ(fifo_reqs$DEQ),
						      .CLR(fifo_reqs$CLR),
						      .D_OUT(fifo_reqs$D_OUT),
						      .FULL_N(fifo_reqs$FULL_N),
						      .EMPTY_N(fifo_reqs$EMPTY_N));

  // submodule fifo_rsps
  FIFO2 #(.width(32'd102), .guarded(32'd1)) fifo_rsps(.RST(RST_N),
						      .CLK(CLK),
						      .D_IN(fifo_rsps$D_IN),
						      .ENQ(fifo_rsps$ENQ),
						      .DEQ(fifo_rsps$DEQ),
						      .CLR(fifo_rsps$CLR),
						      .D_OUT(fifo_rsps$D_OUT),
						      .FULL_N(fifo_rsps$FULL_N),
						      .EMPTY_N(fifo_rsps$EMPTY_N));

  // submodule fifo_sums_memory
  BRAM2 #(.PIPELINED(1'd0),
	  .ADDR_WIDTH(32'd11),
	  .DATA_WIDTH(32'd64),
	  .MEMSIZE(12'd2048)) fifo_sums_memory(.CLKA(CLK),
					       .CLKB(CLK),
					       .ADDRA(fifo_sums_memory$ADDRA),
					       .ADDRB(fifo_sums_memory$ADDRB),
					       .DIA(fifo_sums_memory$DIA),
					       .DIB(fifo_sums_memory$DIB),
					       .WEA(fifo_sums_memory$WEA),
					       .WEB(fifo_sums_memory$WEB),
					       .ENA(fifo_sums_memory$ENA),
					       .ENB(fifo_sums_memory$ENB),
					       .DOA(),
					       .DOB(fifo_sums_memory$DOB));

  // rule RL_rl_rd_gen_0
  assign WILL_FIRE_RL_rl_rd_gen_0 =
	     fifo_reqs$FULL_N && rg_reading && rg_rd_active_2 &&
	     rg_vin1_turn ;

  // rule RL_rl_rd_gen_1
  assign WILL_FIRE_RL_rl_rd_gen_1 =
	     fifo_reqs$FULL_N && !rg_vin1_turn && rg_run_state != 2'd1 ;

  // rule RL_rl_get_x1
  assign WILL_FIRE_RL_rl_get_x1 =
	     fifo_rsps$EMPTY_N && !rg_x1_valid &&
	     fifo_rsps$D_OUT[101:99] == 3'd2 ;

  // rule RL_rl_get_x2_sum_and_gen_wr_reqs
  assign WILL_FIRE_RL_rl_get_x2_sum_and_gen_wr_reqs =
	     fifo_sums_rRdPtr + 12'd1536 != fifo_sums_rWrPtr &&
	     fifo_rsps$EMPTY_N &&
	     rg_x1_valid &&
	     fifo_rsps$D_OUT[101:99] == 3'd2 ;

  // rule RL_rg_wr_gen
  assign CAN_FIRE_RL_rg_wr_gen =
	     fifo_sums_rRdPtr != fifo_sums_rWrPtr && fifo_reqs$FULL_N &&
	     !rg_reading &&
	     rg_wr_active ;
  assign WILL_FIRE_RL_rg_wr_gen =
	     CAN_FIRE_RL_rg_wr_gen && !WILL_FIRE_RL_rl_rd_gen_1 &&
	     rg_run_state != 2'd1 ;

  // rule RL_rg_wr_rsp_drain
  assign WILL_FIRE_RL_rg_wr_rsp_drain =
	     fifo_rsps$EMPTY_N && rg_wr_rsp_drain_count != 16'd0 &&
	     fifo_rsps$D_OUT[101:99] == 3'd3 &&
	     !WILL_FIRE_RL_rg_wr_gen ;

  // inputs to muxes for submodule ports
  assign MUX_rg_reading$write_1__SEL_1 =
	     WILL_FIRE_RL_rl_rd_gen_1 &&
	     (!rg_rd_base_2_3_BITS_47_TO_9_1_CONCAT_rg_rd_bas_ETC___d72 ||
	      rg_rd_pc == 16'd1535) ;
  assign MUX_fifo_reqs$enq_1__VAL_1 =
	     { 9'd67, rg_rd_base_1, 96'h00000000AAAAAAAAAAAAAAAA } ;
  assign MUX_fifo_reqs$enq_1__VAL_2 =
	     { 9'd67, rg_rd_base_2, 96'h00000000AAAAAAAAAAAAAAAA } ;
  assign MUX_fifo_reqs$enq_1__VAL_3 =
	     { 9'd131, rg_wr_base, 32'd0, x3__h3482 } ;
  assign MUX_rg_partial_sum$write_1__VAL_2 = rg_partial_sum + x3__h3375 ;
  assign MUX_rg_rd_active_2$write_1__VAL_2 = rg_rd_base_2 < rg_rd_limit_2 ;
  assign MUX_rg_rd_base_1$write_1__VAL_2 =
	     { rg_rd_base_1_6_BITS_47_TO_9_7_CONCAT_rg_rd_bas_ETC___d50[40:2],
	       rg_rd_base_1[8:6],
	       rg_rd_base_1_6_BITS_47_TO_9_7_CONCAT_rg_rd_bas_ETC___d50[1:0],
	       rg_rd_base_1[3:0] } ;
  assign MUX_rg_rd_pc$write_1__VAL_1 = rg_rd_pc + 16'd1 ;
  assign MUX_rg_wr_active$write_1__VAL_2 = rg_wr_base < rg_wr_limit ;
  assign MUX_rg_wr_pc$write_1__VAL_2 = rg_wr_pc + 16'd1 ;
  assign MUX_rg_wr_rsp_drain_count$write_1__VAL_2 =
	     rg_wr_rsp_drain_count - 16'd1 ;
  assign MUX_rg_wr_rsp_drain_count$write_1__VAL_3 =
	     rg_wr_rsp_drain_count + 16'd1 ;

  // register fifo_sums_rCache
  assign fifo_sums_rCache$D_IN = { 1'd1, fifo_sums_rWrPtr, x3__h1893 } ;
  assign fifo_sums_rCache$EN =
	     rg_run_state != 2'd1 &&
	     WILL_FIRE_RL_rl_get_x2_sum_and_gen_wr_reqs ;

  // register fifo_sums_rRdPtr
  assign fifo_sums_rRdPtr$D_IN = (rg_run_state == 2'd1) ? 12'd0 : x__h2078 ;
  assign fifo_sums_rRdPtr$EN =
	     rg_run_state == 2'd1 || WILL_FIRE_RL_rg_wr_gen ;

  // register fifo_sums_rWrPtr
  assign fifo_sums_rWrPtr$D_IN = (rg_run_state == 2'd1) ? 12'd0 : x__h1976 ;
  assign fifo_sums_rWrPtr$EN =
	     rg_run_state == 2'd1 ||
	     WILL_FIRE_RL_rl_get_x2_sum_and_gen_wr_reqs ;

  // register rg_aeid
  assign rg_aeid$D_IN = start_aeid ;
  assign rg_aeid$EN = EN_start ;

  // register rg_chan
  assign rg_chan$D_IN = start_chan ;
  assign rg_chan$EN = EN_start ;

  // register rg_evenNotOdd
  assign rg_evenNotOdd$D_IN = start_evenNotOdd ;
  assign rg_evenNotOdd$EN = EN_start ;

  // register rg_partial_sum
  assign rg_partial_sum$D_IN =
	     (rg_run_state == 2'd1) ?
	       64'd0 :
	       MUX_rg_partial_sum$write_1__VAL_2 ;
  assign rg_partial_sum$EN =
	     WILL_FIRE_RL_rl_get_x2_sum_and_gen_wr_reqs ||
	     rg_run_state == 2'd1 ;

  // register rg_rd_active_2
  assign rg_rd_active_2$D_IN =
	     WILL_FIRE_RL_rl_rd_gen_1 ?
	       rg_rd_base_2_3_BITS_47_TO_9_1_CONCAT_rg_rd_bas_ETC___d72 :
	       MUX_rg_rd_active_2$write_1__VAL_2 ;
  assign rg_rd_active_2$EN =
	     WILL_FIRE_RL_rl_rd_gen_1 || rg_run_state == 2'd1 ;

  // register rg_rd_base_1
  assign rg_rd_base_1$D_IN =
	     EN_start ? start_rd_base_1 : MUX_rg_rd_base_1$write_1__VAL_2 ;
  assign rg_rd_base_1$EN = EN_start || WILL_FIRE_RL_rl_rd_gen_0 ;

  // register rg_rd_base_2
  assign rg_rd_base_2$D_IN = EN_start ? start_rd_base_2 : next_base__h2815 ;
  assign rg_rd_base_2$EN = EN_start || WILL_FIRE_RL_rl_rd_gen_1 ;

  // register rg_rd_limit_1
  assign rg_rd_limit_1$D_IN = start_rd_limit_1 ;
  assign rg_rd_limit_1$EN = EN_start ;

  // register rg_rd_limit_2
  assign rg_rd_limit_2$D_IN = start_rd_limit_2 ;
  assign rg_rd_limit_2$EN = EN_start ;

  // register rg_rd_pc
  assign rg_rd_pc$D_IN =
	     WILL_FIRE_RL_rl_rd_gen_1 ? MUX_rg_rd_pc$write_1__VAL_1 : 16'd0 ;
  assign rg_rd_pc$EN =
	     WILL_FIRE_RL_rl_rd_gen_1 || rg_run_state == 2'd1 ||
	     WILL_FIRE_RL_rg_wr_gen ;

  // register rg_reading
  assign rg_reading$D_IN = !MUX_rg_reading$write_1__SEL_1 ;
  assign rg_reading$EN =
	     WILL_FIRE_RL_rl_rd_gen_1 &&
	     (!rg_rd_base_2_3_BITS_47_TO_9_1_CONCAT_rg_rd_bas_ETC___d72 ||
	      rg_rd_pc == 16'd1535) ||
	     WILL_FIRE_RL_rg_wr_gen &&
	     (!rg_wr_base_6_BITS_47_TO_9_11_CONCAT_rg_wr_base_ETC___d121 ||
	      rg_wr_pc == 16'd1535) ||
	     rg_run_state == 2'd1 ;

  // register rg_run_state
  always@(EN_result or EN_start or rg_run_state)
  begin
    case (1'b1) // synopsys parallel_case
      EN_result: rg_run_state$D_IN = 2'd0;
      EN_start: rg_run_state$D_IN = 2'd1;
      rg_run_state == 2'd1: rg_run_state$D_IN = 2'd2;
      default: rg_run_state$D_IN = 2'b10 /* unspecified value */ ;
    endcase
  end
  assign rg_run_state$EN = EN_result || EN_start || rg_run_state == 2'd1 ;

  // register rg_vin1_turn
  assign rg_vin1_turn$D_IN =
	     rg_run_state == 2'd1 || WILL_FIRE_RL_rl_rd_gen_1 ;
  assign rg_vin1_turn$EN =
	     WILL_FIRE_RL_rl_rd_gen_0 || WILL_FIRE_RL_rl_rd_gen_1 ||
	     rg_run_state == 2'd1 ;

  // register rg_wr_active
  assign rg_wr_active$D_IN =
	     WILL_FIRE_RL_rg_wr_gen ?
	       rg_wr_base_6_BITS_47_TO_9_11_CONCAT_rg_wr_base_ETC___d121 :
	       MUX_rg_wr_active$write_1__VAL_2 ;
  assign rg_wr_active$EN = WILL_FIRE_RL_rg_wr_gen || rg_run_state == 2'd1 ;

  // register rg_wr_base
  assign rg_wr_base$D_IN = EN_start ? start_wr_base : next_base__h3590 ;
  assign rg_wr_base$EN = EN_start || WILL_FIRE_RL_rg_wr_gen ;

  // register rg_wr_limit
  assign rg_wr_limit$D_IN = start_wr_limit ;
  assign rg_wr_limit$EN = EN_start ;

  // register rg_wr_pc
  always@(rg_run_state or
	  WILL_FIRE_RL_rg_wr_gen or
	  MUX_rg_wr_pc$write_1__VAL_2 or WILL_FIRE_RL_rl_rd_gen_0)
  case (1'b1)
    rg_run_state == 2'd1: rg_wr_pc$D_IN = 16'd0;
    WILL_FIRE_RL_rg_wr_gen: rg_wr_pc$D_IN = MUX_rg_wr_pc$write_1__VAL_2;
    WILL_FIRE_RL_rl_rd_gen_0: rg_wr_pc$D_IN = 16'd0;
    default: rg_wr_pc$D_IN = 16'b1010101010101010 /* unspecified value */ ;
  endcase
  assign rg_wr_pc$EN =
	     WILL_FIRE_RL_rg_wr_gen || WILL_FIRE_RL_rl_rd_gen_0 ||
	     rg_run_state == 2'd1 ;

  // register rg_wr_rsp_drain_count
  always@(rg_run_state or
	  WILL_FIRE_RL_rg_wr_rsp_drain or
	  MUX_rg_wr_rsp_drain_count$write_1__VAL_2 or
	  WILL_FIRE_RL_rg_wr_gen or MUX_rg_wr_rsp_drain_count$write_1__VAL_3)
  case (1'b1)
    rg_run_state == 2'd1: rg_wr_rsp_drain_count$D_IN = 16'd0;
    WILL_FIRE_RL_rg_wr_rsp_drain:
	rg_wr_rsp_drain_count$D_IN = MUX_rg_wr_rsp_drain_count$write_1__VAL_2;
    WILL_FIRE_RL_rg_wr_gen:
	rg_wr_rsp_drain_count$D_IN = MUX_rg_wr_rsp_drain_count$write_1__VAL_3;
    default: rg_wr_rsp_drain_count$D_IN =
		 16'b1010101010101010 /* unspecified value */ ;
  endcase
  assign rg_wr_rsp_drain_count$EN =
	     WILL_FIRE_RL_rg_wr_gen || WILL_FIRE_RL_rg_wr_rsp_drain ||
	     rg_run_state == 2'd1 ;

  // register rg_x1
  assign rg_x1$D_IN = fifo_rsps$D_OUT[63:0] ;
  assign rg_x1$EN = WILL_FIRE_RL_rl_get_x1 ;

  // register rg_x1_valid
  assign rg_x1_valid$D_IN =
	     rg_run_state != 2'd1 &&
	     !WILL_FIRE_RL_rl_get_x2_sum_and_gen_wr_reqs ;
  assign rg_x1_valid$EN =
	     WILL_FIRE_RL_rl_get_x2_sum_and_gen_wr_reqs ||
	     rg_run_state == 2'd1 ||
	     WILL_FIRE_RL_rl_get_x1 ;

  // submodule fifo_reqs
  always@(WILL_FIRE_RL_rl_rd_gen_0 or
	  MUX_fifo_reqs$enq_1__VAL_1 or
	  WILL_FIRE_RL_rl_rd_gen_1 or
	  MUX_fifo_reqs$enq_1__VAL_2 or
	  WILL_FIRE_RL_rg_wr_gen or MUX_fifo_reqs$enq_1__VAL_3)
  begin
    case (1'b1) // synopsys parallel_case
      WILL_FIRE_RL_rl_rd_gen_0: fifo_reqs$D_IN = MUX_fifo_reqs$enq_1__VAL_1;
      WILL_FIRE_RL_rl_rd_gen_1: fifo_reqs$D_IN = MUX_fifo_reqs$enq_1__VAL_2;
      WILL_FIRE_RL_rg_wr_gen: fifo_reqs$D_IN = MUX_fifo_reqs$enq_1__VAL_3;
      default: fifo_reqs$D_IN =
		   153'h0AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA /* unspecified value */ ;
    endcase
  end
  assign fifo_reqs$ENQ =
	     WILL_FIRE_RL_rl_rd_gen_0 || WILL_FIRE_RL_rl_rd_gen_1 ||
	     WILL_FIRE_RL_rg_wr_gen ;
  assign fifo_reqs$DEQ = EN_mc_client_req_rsp_request_get ;
  assign fifo_reqs$CLR = 1'b0 ;

  // submodule fifo_rsps
  assign fifo_rsps$D_IN =
	     { CASE_mc_client_req_rsp_response_put_BITS_101_T_ETC__q2,
	       mc_client_req_rsp_response_put[98:0] } ;
  assign fifo_rsps$ENQ = EN_mc_client_req_rsp_response_put ;
  assign fifo_rsps$DEQ =
	     WILL_FIRE_RL_rl_get_x2_sum_and_gen_wr_reqs ||
	     WILL_FIRE_RL_rl_get_x1 ||
	     WILL_FIRE_RL_rg_wr_rsp_drain ;
  assign fifo_rsps$CLR = 1'b0 ;

  // submodule fifo_sums_memory
  assign fifo_sums_memory$ADDRA = fifo_sums_rWrPtr[10:0] ;
  assign fifo_sums_memory$ADDRB =
	     WILL_FIRE_RL_rg_wr_gen ?
	       x__h2078[10:0] :
	       fifo_sums_rRdPtr[10:0] ;
  assign fifo_sums_memory$DIA = x3__h1893 ;
  assign fifo_sums_memory$DIB =
	     64'hAAAAAAAAAAAAAAAA /* unspecified value */  ;
  assign fifo_sums_memory$WEA = WILL_FIRE_RL_rl_get_x2_sum_and_gen_wr_reqs ;
  assign fifo_sums_memory$WEB = 1'd0 ;
  assign fifo_sums_memory$ENA = rg_run_state != 2'd1 ;
  assign fifo_sums_memory$ENB = rg_run_state != 2'd1 ;

  // remaining internal signals
  assign next_base__h2815 =
	     { rg_rd_base_2_3_BITS_47_TO_9_1_CONCAT_rg_rd_bas_ETC___d64[40:2],
	       rg_rd_base_2[8:6],
	       rg_rd_base_2_3_BITS_47_TO_9_1_CONCAT_rg_rd_bas_ETC___d64[1:0],
	       rg_rd_base_2[3:0] } ;
  assign next_base__h3590 =
	     { rg_wr_base_6_BITS_47_TO_9_11_CONCAT_rg_wr_base_ETC___d114[40:2],
	       rg_wr_base[8:6],
	       rg_wr_base_6_BITS_47_TO_9_11_CONCAT_rg_wr_base_ETC___d114[1:0],
	       rg_wr_base[3:0] } ;
  assign rg_rd_base_1_6_BITS_47_TO_9_7_CONCAT_rg_rd_bas_ETC___d50 =
	     x__h2565 + 41'd1 ;
  assign rg_rd_base_2_3_BITS_47_TO_9_1_CONCAT_rg_rd_bas_ETC___d64 =
	     x__h2839 + 41'd1 ;
  assign rg_rd_base_2_3_BITS_47_TO_9_1_CONCAT_rg_rd_bas_ETC___d72 =
	     next_base__h2815 < rg_rd_limit_2 ;
  assign rg_wr_base_6_BITS_47_TO_9_11_CONCAT_rg_wr_base_ETC___d114 =
	     x__h3613 + 41'd1 ;
  assign rg_wr_base_6_BITS_47_TO_9_11_CONCAT_rg_wr_base_ETC___d121 =
	     next_base__h3590 < rg_wr_limit ;
  assign x3__h1893 =
	     WILL_FIRE_RL_rl_get_x2_sum_and_gen_wr_reqs ?
	       x_wget__h1649 :
	       64'd0 ;
  assign x3__h3375 = x_wget__h1649 ;
  assign x3__h3482 =
	     (fifo_sums_rCache[76] &&
	      fifo_sums_rCache[75:64] == fifo_sums_rRdPtr) ?
	       fifo_sums_rCache[63:0] :
	       fifo_sums_memory$DOB ;
  assign x__h1976 = fifo_sums_rWrPtr + 12'd1 ;
  assign x__h2078 = fifo_sums_rRdPtr + 12'd1 ;
  assign x__h2565 = { rg_rd_base_1[47:9], rg_rd_base_1[5:4] } ;
  assign x__h2839 = { rg_rd_base_2[47:9], rg_rd_base_2[5:4] } ;
  assign x__h3613 = { rg_wr_base[47:9], rg_wr_base[5:4] } ;
  assign x_wget__h1649 = rg_x1 + fifo_rsps$D_OUT[63:0] ;
  always@(fifo_reqs$D_OUT)
  begin
    case (fifo_reqs$D_OUT[152:146])
      7'd16,
      7'd32,
      7'd64,
      7'd65,
      7'd66,
      7'd67,
      7'd68,
      7'd69,
      7'd70,
      7'd71,
      7'd72,
      7'd76,
      7'd80,
      7'd81,
      7'd82,
      7'd83,
      7'd84,
      7'd85,
      7'd86,
      7'd87,
      7'd88,
      7'd89:
	  CASE_fifo_reqsD_OUT_BITS_152_TO_146_16_fifo_r_ETC__q1 =
	      fifo_reqs$D_OUT[152:146];
      default: CASE_fifo_reqsD_OUT_BITS_152_TO_146_16_fifo_r_ETC__q1 = 7'd90;
    endcase
  end
  always@(mc_client_req_rsp_response_put)
  begin
    case (mc_client_req_rsp_response_put[101:99])
      3'd2, 3'd3, 3'd4, 3'd5:
	  CASE_mc_client_req_rsp_response_put_BITS_101_T_ETC__q2 =
	      mc_client_req_rsp_response_put[101:99];
      default: CASE_mc_client_req_rsp_response_put_BITS_101_T_ETC__q2 = 3'd6;
    endcase
  end

  // handling of inlined registers

  always@(posedge CLK)
  begin
    if (!`BSV_RESET_VALUE == `BSV_RESET_VALUE)
      begin
        fifo_sums_rCache <= `BSV_ASSIGNMENT_DELAY 77'h0AAAAAAAAAAAAAAAAAAA;
	fifo_sums_rRdPtr <= `BSV_ASSIGNMENT_DELAY 12'd0;
	fifo_sums_rWrPtr <= `BSV_ASSIGNMENT_DELAY 12'd0;
      end
    else
      begin
        if (fifo_sums_rCache$EN)
	  fifo_sums_rCache <= `BSV_ASSIGNMENT_DELAY fifo_sums_rCache$D_IN;
	if (fifo_sums_rRdPtr$EN)
	  fifo_sums_rRdPtr <= `BSV_ASSIGNMENT_DELAY fifo_sums_rRdPtr$D_IN;
	if (fifo_sums_rWrPtr$EN)
	  fifo_sums_rWrPtr <= `BSV_ASSIGNMENT_DELAY fifo_sums_rWrPtr$D_IN;
      end
    if (RST_N == `BSV_RESET_VALUE)
      begin
        rg_rd_active_2 <= `BSV_ASSIGNMENT_DELAY 1'd0;
	rg_run_state <= `BSV_ASSIGNMENT_DELAY 2'd0;
	rg_wr_active <= `BSV_ASSIGNMENT_DELAY 1'd0;
      end
    else
      begin
        if (rg_rd_active_2$EN)
	  rg_rd_active_2 <= `BSV_ASSIGNMENT_DELAY rg_rd_active_2$D_IN;
	if (rg_run_state$EN)
	  rg_run_state <= `BSV_ASSIGNMENT_DELAY rg_run_state$D_IN;
	if (rg_wr_active$EN)
	  rg_wr_active <= `BSV_ASSIGNMENT_DELAY rg_wr_active$D_IN;
      end
    if (rg_aeid$EN) rg_aeid <= `BSV_ASSIGNMENT_DELAY rg_aeid$D_IN;
    if (rg_chan$EN) rg_chan <= `BSV_ASSIGNMENT_DELAY rg_chan$D_IN;
    if (rg_evenNotOdd$EN)
      rg_evenNotOdd <= `BSV_ASSIGNMENT_DELAY rg_evenNotOdd$D_IN;
    if (rg_partial_sum$EN)
      rg_partial_sum <= `BSV_ASSIGNMENT_DELAY rg_partial_sum$D_IN;
    if (rg_rd_base_1$EN)
      rg_rd_base_1 <= `BSV_ASSIGNMENT_DELAY rg_rd_base_1$D_IN;
    if (rg_rd_base_2$EN)
      rg_rd_base_2 <= `BSV_ASSIGNMENT_DELAY rg_rd_base_2$D_IN;
    if (rg_rd_limit_1$EN)
      rg_rd_limit_1 <= `BSV_ASSIGNMENT_DELAY rg_rd_limit_1$D_IN;
    if (rg_rd_limit_2$EN)
      rg_rd_limit_2 <= `BSV_ASSIGNMENT_DELAY rg_rd_limit_2$D_IN;
    if (rg_rd_pc$EN) rg_rd_pc <= `BSV_ASSIGNMENT_DELAY rg_rd_pc$D_IN;
    if (rg_reading$EN) rg_reading <= `BSV_ASSIGNMENT_DELAY rg_reading$D_IN;
    if (rg_vin1_turn$EN)
      rg_vin1_turn <= `BSV_ASSIGNMENT_DELAY rg_vin1_turn$D_IN;
    if (rg_wr_base$EN) rg_wr_base <= `BSV_ASSIGNMENT_DELAY rg_wr_base$D_IN;
    if (rg_wr_limit$EN) rg_wr_limit <= `BSV_ASSIGNMENT_DELAY rg_wr_limit$D_IN;
    if (rg_wr_pc$EN) rg_wr_pc <= `BSV_ASSIGNMENT_DELAY rg_wr_pc$D_IN;
    if (rg_wr_rsp_drain_count$EN)
      rg_wr_rsp_drain_count <= `BSV_ASSIGNMENT_DELAY
	  rg_wr_rsp_drain_count$D_IN;
    if (rg_x1$EN) rg_x1 <= `BSV_ASSIGNMENT_DELAY rg_x1$D_IN;
    if (rg_x1_valid$EN) rg_x1_valid <= `BSV_ASSIGNMENT_DELAY rg_x1_valid$D_IN;
  end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    fifo_sums_rCache = 77'h0AAAAAAAAAAAAAAAAAAA;
    fifo_sums_rRdPtr = 12'hAAA;
    fifo_sums_rWrPtr = 12'hAAA;
    rg_aeid = 2'h2;
    rg_chan = 3'h2;
    rg_evenNotOdd = 1'h0;
    rg_partial_sum = 64'hAAAAAAAAAAAAAAAA;
    rg_rd_active_2 = 1'h0;
    rg_rd_base_1 = 48'hAAAAAAAAAAAA;
    rg_rd_base_2 = 48'hAAAAAAAAAAAA;
    rg_rd_limit_1 = 48'hAAAAAAAAAAAA;
    rg_rd_limit_2 = 48'hAAAAAAAAAAAA;
    rg_rd_pc = 16'hAAAA;
    rg_reading = 1'h0;
    rg_run_state = 2'h2;
    rg_vin1_turn = 1'h0;
    rg_wr_active = 1'h0;
    rg_wr_base = 48'hAAAAAAAAAAAA;
    rg_wr_limit = 48'hAAAAAAAAAAAA;
    rg_wr_pc = 16'hAAAA;
    rg_wr_rsp_drain_count = 16'hAAAA;
    rg_x1 = 64'hAAAAAAAAAAAAAAAA;
    rg_x1_valid = 1'h0;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkChanVadd

